import { Meta } from '@storybook/addon-docs/blocks';

<Meta title="Internal/Documentation/Public API" />

# Public API Conventions

## Component APIs

- Custom Elements (Web Components) should be prefixed with `cds-`.
- There is no prefix on public custom element attributes or properties.
- Style attributes related to sizes should use t-shirt style values. Example
  `size="sm"` ... xs, sm, md, lg, xl xxl
- Events/props should follow Angular/Vue style naming conventions of using a
  present tense verb + `change`. Example, property `open` and event `openChange`.

These component conventions allow frameworks to consume the Web easily. The convention
is also needed so extend libraries like our React wrappers `@clr/react` can parse
and set up the React version of the event. `openChange` => `onOpenChange`.

Components primarily communicate the following ways:

- properties/attrs (data in)
- custom events (data out)
- slots (content projection)

```html
<!--
  Example of a modal web component in Angular
  - `size` is a attribute style hook
  - [open] is setting a property on the element
  - (openChange) is listening for the `openChange` custom event
-->
<cds-modal size="lg" [open]="true" (openChange)="log($event.detail)">
  <p>slot content</p>
</cds-modal>
```

```html
<!--
  Example of a modal web component in Vue
  - `size` is a attribute style hook
  - :open is setting a property on the element
  - @openChange is listening for the `openChange` custom event
-->
<cds-modal size="lg" :open="true" @openChange="log($event.detail)">
  <p>slot content</p>
</cds-modal>
```

```jsx
{
  /*
  Example of a modal web component in React with @clr/react wrapper
  - `size` is an attribute style hook
  - open is setting a property on the element
  - openChange is listening for the `openChange` custom event
*/
}
<CdsModal size="lg" open={this.state.open} onOpenChange={this.log}>
  <p>slot content</p>
</CdsModal>;
```

## Public Import APIs

Public Components are exported with a side effect free file import. Public
Utilities are only exported through the top-level import path. To register a
component to use, we export a stand-alone `register.js` side effect import.

```typescript
import { CommonStrings } from '@clr/core'; // utilities
import { CdsButton } from '@clr/core/button'; // component class
import '@clr/core/button/register.js'; // register and use component
```

By keeping the component registration as a separate side effect import, we ensure
proper tree shaking at a component and symbol level. This convention also future
proofs our API to allow our components to be aliased.
https://github.com/w3c/webcomponents/issues/716

Overall we try to avoid users from importing anything by direct file
or with deep import paths as this is reaching into the library internals, which
can change. The `@clr/core/internal` module is an internal private module for shared
utilities between components.
